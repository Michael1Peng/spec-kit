# 模板同步管理模块调用流程分析

## 流程图1: 新功能创建和模板复制流程

```
新功能创建和模板复制链
============================

create-new-feature.sh@scripts/bash/create-new-feature.sh
    ↓ 传递: FEATURE_DESCRIPTION (用户输入的功能描述)
git rev-parse --show-toplevel@scripts/bash/create-new-feature.sh:21
    ↓ 传递: REPO_ROOT (仓库根目录路径)
    ↓ 返回: 仓库根目录绝对路径
mkdir -p "$SPECS_DIR"@scripts/bash/create-new-feature.sh:23
    ↓ 传递: "$REPO_ROOT/specs" (规格目录路径)
目录扫描循环@scripts/bash/create-new-feature.sh:26-34
    ↓ 传递: 现有目录名列表
    ↓ 提取: 目录编号 (grep -o '^[0-9]\+')
    ↓ 返回: HIGHEST (最大编号)
计算下一个编号@scripts/bash/create-new-feature.sh:36-37
    ↓ 传递: NEXT = HIGHEST + 1
    ↓ 返回: FEATURE_NUM (格式化的三位数编号)
分支名称生成@scripts/bash/create-new-feature.sh:39-41
    ↓ 传递: FEATURE_DESCRIPTION
    ↓ 处理: 小写转换, 特殊字符替换, 截取前3个单词
    ↓ 返回: BRANCH_NAME (格式: 001-feature-words)
git checkout -b "$BRANCH_NAME"@scripts/bash/create-new-feature.sh:43
    ↓ 传递: BRANCH_NAME
    ↓ 执行: 创建并切换到新分支
mkdir -p "$FEATURE_DIR"@scripts/bash/create-new-feature.sh:46
    ↓ 传递: "$SPECS_DIR/$BRANCH_NAME" (功能目录路径)
模板复制操作@scripts/bash/create-new-feature.sh:50
    ↓ 传递: TEMPLATE="$REPO_ROOT/templates/spec-template.md"
    ↓ 传递: SPEC_FILE="$FEATURE_DIR/spec.md"
    ↓ 执行: cp "$TEMPLATE" "$SPEC_FILE" (如果模板存在)
    ↓ 备选: touch "$SPEC_FILE" (如果模板不存在)
```

## 流程图2: 计划设置和模板同步流程

```
计划设置和模板同步链
======================

setup-plan.sh@scripts/bash/setup-plan.sh
    ↓ 传递: JSON_MODE (布尔值)
source "$SCRIPT_DIR/common.sh"@scripts/bash/setup-plan.sh:6
    ↓ 传递: void
    ↓ 加载: 公共函数库
get_feature_paths()@scripts/bash/common.sh:18-34
    ↓ 传递: void
    ↓ 返回: 环境变量字符串 (REPO_ROOT, CURRENT_BRANCH, FEATURE_DIR等)
eval $(get_feature_paths)@scripts/bash/setup-plan.sh:7
    ↓ 传递: 路径变量设置命令
    ↓ 执行: 设置所有功能相关路径变量
check_feature_branch()@scripts/bash/common.sh:7-14
    ↓ 传递: CURRENT_BRANCH
    ↓ 验证: 分支名格式 (^[0-9]{3}-)
    ↓ 返回: 成功(0) 或 失败(1)
mkdir -p "$FEATURE_DIR"@scripts/bash/setup-plan.sh:9
    ↓ 传递: FEATURE_DIR (功能目录路径)
模板检查和复制@scripts/bash/setup-plan.sh:10-11
    ↓ 传递: TEMPLATE="$REPO_ROOT/.specify/templates/plan-template.md"
    ↓ 传递: IMPL_PLAN="$FEATURE_DIR/plan.md"
    ↓ 条件执行: [[ -f "$TEMPLATE" ]] && cp "$TEMPLATE" "$IMPL_PLAN"
输出结果@scripts/bash/setup-plan.sh:12-17
    ↓ 分支: JSON_MODE 判断
    ↓ JSON输出: printf JSON格式
    ↓ 文本输出: echo 键值对格式
```

## 流程图3: 代理上下文文件更新和模板管理流程

```
代理上下文更新和模板同步链
=============================

update-agent-context.sh@scripts/bash/update-agent-context.sh
    ↓ 传递: AGENT_TYPE (claude|gemini|copilot|cursor)
环境变量初始化@scripts/bash/update-agent-context.sh:3-7
    ↓ 传递: REPO_ROOT, CURRENT_BRANCH, FEATURE_DIR
    ↓ 设置: 各代理配置文件路径 (CLAUDE_FILE, GEMINI_FILE等)
计划文件验证@scripts/bash/update-agent-context.sh:9
    ↓ 传递: NEW_PLAN="$FEATURE_DIR/plan.md"
    ↓ 检查: [ -f "$NEW_PLAN" ] 文件存在性
信息提取@scripts/bash/update-agent-context.sh:11-14
    ↓ 传递: NEW_PLAN 文件内容
    ↓ 提取: NEW_LANG (语言版本)
    ↓ 提取: NEW_FRAMEWORK (主要依赖)
    ↓ 提取: NEW_DB (存储)
    ↓ 提取: NEW_PROJECT_TYPE (项目类型)
    ↓ 过滤: grep -v "NEEDS CLARIFICATION"

新文件创建分支:
[ ! -f "$target_file" ]@scripts/bash/update-agent-context.sh:15
    ↓ 分支: 目标文件不存在
模板复制@scripts/bash/update-agent-context.sh:16
    ↓ 传递: "$REPO_ROOT/templates/agent-file-template.md"
    ↓ 执行: cp "$REPO_ROOT/templates/agent-file-template.md" "$temp_file"
    ↓ 错误处理: 模板文件不存在时返回错误
模板变量替换@scripts/bash/update-agent-context.sh:17-20
    ↓ 传递: temp_file 内容
    ↓ 替换: [PROJECT NAME] → 仓库名
    ↓ 替换: [DATE] → 当前日期
    ↓ 替换: [EXTRACTED FROM ALL PLAN.MD FILES] → 技术栈信息
    ↓ 替换: [ACTUAL STRUCTURE FROM PLANS] → 项目结构
    ↓ 替换: [ONLY COMMANDS FOR ACTIVE TECHNOLOGIES] → 命令集
    ↓ 替换: [LANGUAGE-SPECIFIC, ONLY FOR LANGUAGES IN USE] → 语言规范
    ↓ 替换: [LAST 3 FEATURES AND WHAT THEY ADDED] → 功能历史

现有文件更新分支:
文件存在@scripts/bash/update-agent-context.sh:21-22
    ↓ 分支: 目标文件已存在
手动添加内容保护@scripts/bash/update-agent-context.sh:22
    ↓ 提取: <!-- MANUAL ADDITIONS START --> 到 <!-- MANUAL ADDITIONS END -->
    ↓ 保存: /tmp/manual_additions.txt
Python脚本更新@scripts/bash/update-agent-context.sh:23-47
    ↓ 传递: target_file, NEW_LANG, NEW_FRAMEWORK等变量
    ↓ 更新: ## Active Technologies 部分
    ↓ 更新: ## Recent Changes 部分 (保持最新3条)
    ↓ 更新: Last updated 时间戳
手动内容恢复@scripts/bash/update-agent-context.sh:48
    ↓ 传递: /tmp/manual_additions.txt 内容
    ↓ 恢复: 手动添加的配置内容

代理类型分发@scripts/bash/update-agent-context.sh:50-61
    ↓ 传递: AGENT_TYPE 参数
    ↓ claude分支: update_agent_file "$CLAUDE_FILE" "Claude Code"
    ↓ gemini分支: update_agent_file "$GEMINI_FILE" "Gemini CLI"
    ↓ copilot分支: update_agent_file "$COPILOT_FILE" "GitHub Copilot"
    ↓ cursor分支: update_agent_file "$CURSOR_FILE" "Cursor IDE"
    ↓ 空参数分支: 更新所有存在的代理文件
```

## 流程图4: 通用路径和功能管理流程

```
通用功能和路径管理链
======================

common.sh@scripts/bash/common.sh
    ↓ 提供: 公共函数库
get_repo_root()@scripts/bash/common.sh:4
    ↓ 执行: git rev-parse --show-toplevel
    ↓ 返回: 仓库根目录绝对路径
get_current_branch()@scripts/bash/common.sh:5
    ↓ 执行: git rev-parse --abbrev-ref HEAD
    ↓ 返回: 当前分支名
check_feature_branch()@scripts/bash/common.sh:7-14
    ↓ 传递: branch (分支名)
    ↓ 验证: 正则表达式 ^[0-9]{3}-
    ↓ 错误输出: 分支格式不正确时的错误信息
    ↓ 返回: 0(成功) 或 1(失败)
get_feature_dir()@scripts/bash/common.sh:16
    ↓ 传递: repo_root, branch_name
    ↓ 返回: "$repo_root/specs/$branch_name"
get_feature_paths()@scripts/bash/common.sh:18-34
    ↓ 调用: get_repo_root(), get_current_branch()
    ↓ 计算: feature_dir 路径
    ↓ 生成: 完整路径变量集合
    ↓ 输出: REPO_ROOT, CURRENT_BRANCH, FEATURE_DIR等环境变量
cat <<EOF 输出@scripts/bash/common.sh:22-33
    ↓ 传递: 多行环境变量赋值语句
    ↓ 包含: FEATURE_SPEC, IMPL_PLAN, TASKS等文件路径
    ↓ 包含: RESEARCH, DATA_MODEL, QUICKSTART文件路径
    ↓ 包含: CONTRACTS_DIR 目录路径
check_file()@scripts/bash/common.sh:36
    ↓ 传递: file_path, description
    ↓ 检查: [[ -f "$1" ]] 文件存在性
    ↓ 输出: ✓ 或 ✗ 状态标记
check_dir()@scripts/bash/common.sh:37
    ↓ 传递: dir_path, description
    ↓ 检查: [[ -d "$1" && -n $(ls -A "$1" 2>/dev/null) ]] 目录存在性和非空性
    ↓ 输出: ✓ 或 ✗ 状态标记
```